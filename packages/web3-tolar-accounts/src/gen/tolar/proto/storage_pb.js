// source: tolar/proto/storage.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var tolar_proto_transaction_pb = require('../../tolar/proto/transaction_pb.js');
goog.object.extend(proto, tolar_proto_transaction_pb);
goog.exportSymbol('proto.tolar.proto.storage.Block', null, global);
goog.exportSymbol('proto.tolar.proto.storage.BlockBody', null, global);
goog.exportSymbol('proto.tolar.proto.storage.EventFirstDescendants', null, global);
goog.exportSymbol('proto.tolar.proto.storage.EventLastAncestors', null, global);
goog.exportSymbol('proto.tolar.proto.storage.EventMetadata', null, global);
goog.exportSymbol('proto.tolar.proto.storage.EventRelations', null, global);
goog.exportSymbol('proto.tolar.proto.storage.EventRelationsLookupElement', null, global);
goog.exportSymbol('proto.tolar.proto.storage.InitialEvents', null, global);
goog.exportSymbol('proto.tolar.proto.storage.InitialEventsElement', null, global);
goog.exportSymbol('proto.tolar.proto.storage.LastBlockChainState', null, global);
goog.exportSymbol('proto.tolar.proto.storage.LastBlockchainPendingEvent', null, global);
goog.exportSymbol('proto.tolar.proto.storage.LatestValidBlock', null, global);
goog.exportSymbol('proto.tolar.proto.storage.RecoverySnapshot', null, global);
goog.exportSymbol('proto.tolar.proto.storage.SentinelRank', null, global);
goog.exportSymbol('proto.tolar.proto.storage.Snapshot', null, global);
goog.exportSymbol('proto.tolar.proto.storage.SnapshotElement', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.EventMetadata = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.tolar.proto.storage.EventMetadata, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.EventMetadata.displayName = 'proto.tolar.proto.storage.EventMetadata';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.SnapshotElement = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.tolar.proto.storage.SnapshotElement, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.SnapshotElement.displayName = 'proto.tolar.proto.storage.SnapshotElement';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.Snapshot = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tolar.proto.storage.Snapshot.repeatedFields_, null);
};
goog.inherits(proto.tolar.proto.storage.Snapshot, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.Snapshot.displayName = 'proto.tolar.proto.storage.Snapshot';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tolar.proto.storage.LastBlockchainPendingEvent.repeatedFields_, null);
};
goog.inherits(proto.tolar.proto.storage.LastBlockchainPendingEvent, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.LastBlockchainPendingEvent.displayName = 'proto.tolar.proto.storage.LastBlockchainPendingEvent';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.LastBlockChainState = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tolar.proto.storage.LastBlockChainState.repeatedFields_, null);
};
goog.inherits(proto.tolar.proto.storage.LastBlockChainState, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.LastBlockChainState.displayName = 'proto.tolar.proto.storage.LastBlockChainState';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.RecoverySnapshot = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.tolar.proto.storage.RecoverySnapshot, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.RecoverySnapshot.displayName = 'proto.tolar.proto.storage.RecoverySnapshot';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.BlockBody = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tolar.proto.storage.BlockBody.repeatedFields_, null);
};
goog.inherits(proto.tolar.proto.storage.BlockBody, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.BlockBody.displayName = 'proto.tolar.proto.storage.BlockBody';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.Block = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tolar.proto.storage.Block.repeatedFields_, null);
};
goog.inherits(proto.tolar.proto.storage.Block, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.Block.displayName = 'proto.tolar.proto.storage.Block';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.EventRelationsLookupElement = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.tolar.proto.storage.EventRelationsLookupElement, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.EventRelationsLookupElement.displayName = 'proto.tolar.proto.storage.EventRelationsLookupElement';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.EventRelations = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tolar.proto.storage.EventRelations.repeatedFields_, null);
};
goog.inherits(proto.tolar.proto.storage.EventRelations, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.EventRelations.displayName = 'proto.tolar.proto.storage.EventRelations';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.EventLastAncestors = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.tolar.proto.storage.EventLastAncestors, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.EventLastAncestors.displayName = 'proto.tolar.proto.storage.EventLastAncestors';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.EventFirstDescendants = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.tolar.proto.storage.EventFirstDescendants, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.EventFirstDescendants.displayName = 'proto.tolar.proto.storage.EventFirstDescendants';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.LatestValidBlock = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.tolar.proto.storage.LatestValidBlock, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.LatestValidBlock.displayName = 'proto.tolar.proto.storage.LatestValidBlock';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.InitialEventsElement = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.tolar.proto.storage.InitialEventsElement, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.InitialEventsElement.displayName = 'proto.tolar.proto.storage.InitialEventsElement';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.tolar.proto.storage.InitialEvents = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tolar.proto.storage.InitialEvents.repeatedFields_, null);
};
goog.inherits(proto.tolar.proto.storage.InitialEvents, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tolar.proto.storage.InitialEvents.displayName = 'proto.tolar.proto.storage.InitialEvents';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.EventMetadata.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.EventMetadata.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.EventMetadata} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.EventMetadata.toObject = function(includeInstance, msg) {
  var f, obj = {
    eventHash: msg.getEventHash_asB64(),
    isSentinel: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
    rank: jspb.Message.getFieldWithDefault(msg, 3, 0),
    consensusTimestamp: jspb.Message.getFieldWithDefault(msg, 4, 0),
    roundReceived: jspb.Message.getFieldWithDefault(msg, 5, 0),
    roundCreated: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.EventMetadata}
 */
proto.tolar.proto.storage.EventMetadata.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.EventMetadata;
  return proto.tolar.proto.storage.EventMetadata.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.EventMetadata} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.EventMetadata}
 */
proto.tolar.proto.storage.EventMetadata.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEventHash(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsSentinel(value);
      break;
    case 3:
      var value = /** @type {!proto.tolar.proto.storage.SentinelRank} */ (reader.readEnum());
      msg.setRank(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setConsensusTimestamp(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setRoundReceived(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setRoundCreated(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.EventMetadata.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.EventMetadata.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.EventMetadata} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.EventMetadata.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEventHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getIsSentinel();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getRank();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = message.getConsensusTimestamp();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = message.getRoundReceived();
  if (f !== 0) {
    writer.writeUint64(
      5,
      f
    );
  }
  f = message.getRoundCreated();
  if (f !== 0) {
    writer.writeUint64(
      6,
      f
    );
  }
};


/**
 * optional bytes event_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.EventMetadata.prototype.getEventHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes event_hash = 1;
 * This is a type-conversion wrapper around `getEventHash()`
 * @return {string}
 */
proto.tolar.proto.storage.EventMetadata.prototype.getEventHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEventHash()));
};


/**
 * optional bytes event_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEventHash()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.EventMetadata.prototype.getEventHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEventHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.EventMetadata} returns this
 */
proto.tolar.proto.storage.EventMetadata.prototype.setEventHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bool is_sentinel = 2;
 * @return {boolean}
 */
proto.tolar.proto.storage.EventMetadata.prototype.getIsSentinel = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.tolar.proto.storage.EventMetadata} returns this
 */
proto.tolar.proto.storage.EventMetadata.prototype.setIsSentinel = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional SentinelRank rank = 3;
 * @return {!proto.tolar.proto.storage.SentinelRank}
 */
proto.tolar.proto.storage.EventMetadata.prototype.getRank = function() {
  return /** @type {!proto.tolar.proto.storage.SentinelRank} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {!proto.tolar.proto.storage.SentinelRank} value
 * @return {!proto.tolar.proto.storage.EventMetadata} returns this
 */
proto.tolar.proto.storage.EventMetadata.prototype.setRank = function(value) {
  return jspb.Message.setProto3EnumField(this, 3, value);
};


/**
 * optional uint64 consensus_timestamp = 4;
 * @return {number}
 */
proto.tolar.proto.storage.EventMetadata.prototype.getConsensusTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.EventMetadata} returns this
 */
proto.tolar.proto.storage.EventMetadata.prototype.setConsensusTimestamp = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional uint64 round_received = 5;
 * @return {number}
 */
proto.tolar.proto.storage.EventMetadata.prototype.getRoundReceived = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.EventMetadata} returns this
 */
proto.tolar.proto.storage.EventMetadata.prototype.setRoundReceived = function(value) {
  return jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional uint64 round_created = 6;
 * @return {number}
 */
proto.tolar.proto.storage.EventMetadata.prototype.getRoundCreated = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.EventMetadata} returns this
 */
proto.tolar.proto.storage.EventMetadata.prototype.setRoundCreated = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.SnapshotElement.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.SnapshotElement.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.SnapshotElement} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.SnapshotElement.toObject = function(includeInstance, msg) {
  var f, obj = {
    chainId: msg.getChainId_asB64(),
    hash: msg.getHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.SnapshotElement}
 */
proto.tolar.proto.storage.SnapshotElement.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.SnapshotElement;
  return proto.tolar.proto.storage.SnapshotElement.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.SnapshotElement} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.SnapshotElement}
 */
proto.tolar.proto.storage.SnapshotElement.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChainId(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.SnapshotElement.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.SnapshotElement.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.SnapshotElement} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.SnapshotElement.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChainId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes chain_id = 1;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.SnapshotElement.prototype.getChainId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes chain_id = 1;
 * This is a type-conversion wrapper around `getChainId()`
 * @return {string}
 */
proto.tolar.proto.storage.SnapshotElement.prototype.getChainId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChainId()));
};


/**
 * optional bytes chain_id = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChainId()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.SnapshotElement.prototype.getChainId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChainId()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.SnapshotElement} returns this
 */
proto.tolar.proto.storage.SnapshotElement.prototype.setChainId = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.SnapshotElement.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes hash = 2;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.tolar.proto.storage.SnapshotElement.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.SnapshotElement.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.SnapshotElement} returns this
 */
proto.tolar.proto.storage.SnapshotElement.prototype.setHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.tolar.proto.storage.Snapshot.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.Snapshot.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.Snapshot.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.Snapshot} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.Snapshot.toObject = function(includeInstance, msg) {
  var f, obj = {
    elementsList: jspb.Message.toObjectList(msg.getElementsList(),
    proto.tolar.proto.storage.SnapshotElement.toObject, includeInstance),
    id: msg.getId_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.Snapshot}
 */
proto.tolar.proto.storage.Snapshot.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.Snapshot;
  return proto.tolar.proto.storage.Snapshot.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.Snapshot} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.Snapshot}
 */
proto.tolar.proto.storage.Snapshot.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.tolar.proto.storage.SnapshotElement;
      reader.readMessage(value,proto.tolar.proto.storage.SnapshotElement.deserializeBinaryFromReader);
      msg.addElements(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.Snapshot.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.Snapshot.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.Snapshot} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.Snapshot.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getElementsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.tolar.proto.storage.SnapshotElement.serializeBinaryToWriter
    );
  }
  f = message.getId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * repeated SnapshotElement elements = 1;
 * @return {!Array<!proto.tolar.proto.storage.SnapshotElement>}
 */
proto.tolar.proto.storage.Snapshot.prototype.getElementsList = function() {
  return /** @type{!Array<!proto.tolar.proto.storage.SnapshotElement>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.tolar.proto.storage.SnapshotElement, 1));
};


/**
 * @param {!Array<!proto.tolar.proto.storage.SnapshotElement>} value
 * @return {!proto.tolar.proto.storage.Snapshot} returns this
*/
proto.tolar.proto.storage.Snapshot.prototype.setElementsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.tolar.proto.storage.SnapshotElement=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tolar.proto.storage.SnapshotElement}
 */
proto.tolar.proto.storage.Snapshot.prototype.addElements = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tolar.proto.storage.SnapshotElement, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.tolar.proto.storage.Snapshot} returns this
 */
proto.tolar.proto.storage.Snapshot.prototype.clearElementsList = function() {
  return this.setElementsList([]);
};


/**
 * optional bytes id = 2;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.Snapshot.prototype.getId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes id = 2;
 * This is a type-conversion wrapper around `getId()`
 * @return {string}
 */
proto.tolar.proto.storage.Snapshot.prototype.getId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getId()));
};


/**
 * optional bytes id = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getId()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.Snapshot.prototype.getId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getId()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.Snapshot} returns this
 */
proto.tolar.proto.storage.Snapshot.prototype.setId = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.LastBlockchainPendingEvent.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.LastBlockchainPendingEvent} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.toObject = function(includeInstance, msg) {
  var f, obj = {
    roundReceived: jspb.Message.getFieldWithDefault(msg, 1, 0),
    eventsProofHash: msg.getEventsProofHash_asB64(),
    timestamp: jspb.Message.getFieldWithDefault(msg, 3, 0),
    transactionsList: jspb.Message.toObjectList(msg.getTransactionsList(),
    tolar_proto_transaction_pb.SignedTransaction.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.LastBlockchainPendingEvent}
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.LastBlockchainPendingEvent;
  return proto.tolar.proto.storage.LastBlockchainPendingEvent.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.LastBlockchainPendingEvent} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.LastBlockchainPendingEvent}
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setRoundReceived(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEventsProofHash(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTimestamp(value);
      break;
    case 4:
      var value = new tolar_proto_transaction_pb.SignedTransaction;
      reader.readMessage(value,tolar_proto_transaction_pb.SignedTransaction.deserializeBinaryFromReader);
      msg.addTransactions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.LastBlockchainPendingEvent.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.LastBlockchainPendingEvent} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoundReceived();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getEventsProofHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = message.getTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      tolar_proto_transaction_pb.SignedTransaction.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 round_received = 1;
 * @return {number}
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.getRoundReceived = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.LastBlockchainPendingEvent} returns this
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.setRoundReceived = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional bytes events_proof_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.getEventsProofHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes events_proof_hash = 2;
 * This is a type-conversion wrapper around `getEventsProofHash()`
 * @return {string}
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.getEventsProofHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEventsProofHash()));
};


/**
 * optional bytes events_proof_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEventsProofHash()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.getEventsProofHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEventsProofHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.LastBlockchainPendingEvent} returns this
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.setEventsProofHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional uint64 timestamp = 3;
 * @return {number}
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.LastBlockchainPendingEvent} returns this
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.setTimestamp = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * repeated tolar.proto.tx.SignedTransaction transactions = 4;
 * @return {!Array<!proto.tolar.proto.tx.SignedTransaction>}
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.getTransactionsList = function() {
  return /** @type{!Array<!proto.tolar.proto.tx.SignedTransaction>} */ (
    jspb.Message.getRepeatedWrapperField(this, tolar_proto_transaction_pb.SignedTransaction, 4));
};


/**
 * @param {!Array<!proto.tolar.proto.tx.SignedTransaction>} value
 * @return {!proto.tolar.proto.storage.LastBlockchainPendingEvent} returns this
*/
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.setTransactionsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.tolar.proto.tx.SignedTransaction=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tolar.proto.tx.SignedTransaction}
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.addTransactions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.tolar.proto.tx.SignedTransaction, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.tolar.proto.storage.LastBlockchainPendingEvent} returns this
 */
proto.tolar.proto.storage.LastBlockchainPendingEvent.prototype.clearTransactionsList = function() {
  return this.setTransactionsList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.tolar.proto.storage.LastBlockChainState.repeatedFields_ = [4,7];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.LastBlockChainState.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.LastBlockChainState} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.LastBlockChainState.toObject = function(includeInstance, msg) {
  var f, obj = {
    lastBlockIndex: jspb.Message.getFieldWithDefault(msg, 1, 0),
    lastRoundReceived: jspb.Message.getFieldWithDefault(msg, 2, 0),
    lastBlockHash: msg.getLastBlockHash_asB64(),
    pendingBlockEventsList: jspb.Message.toObjectList(msg.getPendingBlockEventsList(),
    proto.tolar.proto.storage.LastBlockchainPendingEvent.toObject, includeInstance),
    lastEventsProofHash: msg.getLastEventsProofHash_asB64(),
    nextPendingEventIndex: jspb.Message.getFieldWithDefault(msg, 6, 0),
    newEventsList: jspb.Message.toObjectList(msg.getNewEventsList(),
    proto.tolar.proto.storage.LastBlockchainPendingEvent.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.LastBlockChainState}
 */
proto.tolar.proto.storage.LastBlockChainState.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.LastBlockChainState;
  return proto.tolar.proto.storage.LastBlockChainState.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.LastBlockChainState} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.LastBlockChainState}
 */
proto.tolar.proto.storage.LastBlockChainState.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setLastBlockIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setLastRoundReceived(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setLastBlockHash(value);
      break;
    case 4:
      var value = new proto.tolar.proto.storage.LastBlockchainPendingEvent;
      reader.readMessage(value,proto.tolar.proto.storage.LastBlockchainPendingEvent.deserializeBinaryFromReader);
      msg.addPendingBlockEvents(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setLastEventsProofHash(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNextPendingEventIndex(value);
      break;
    case 7:
      var value = new proto.tolar.proto.storage.LastBlockchainPendingEvent;
      reader.readMessage(value,proto.tolar.proto.storage.LastBlockchainPendingEvent.deserializeBinaryFromReader);
      msg.addNewEvents(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.LastBlockChainState.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.LastBlockChainState} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.LastBlockChainState.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLastBlockIndex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getLastRoundReceived();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getLastBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getPendingBlockEventsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.tolar.proto.storage.LastBlockchainPendingEvent.serializeBinaryToWriter
    );
  }
  f = message.getLastEventsProofHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getNextPendingEventIndex();
  if (f !== 0) {
    writer.writeUint64(
      6,
      f
    );
  }
  f = message.getNewEventsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      7,
      f,
      proto.tolar.proto.storage.LastBlockchainPendingEvent.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 last_block_index = 1;
 * @return {number}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.getLastBlockIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.LastBlockChainState} returns this
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.setLastBlockIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 last_round_received = 2;
 * @return {number}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.getLastRoundReceived = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.LastBlockChainState} returns this
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.setLastRoundReceived = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes last_block_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.getLastBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes last_block_hash = 3;
 * This is a type-conversion wrapper around `getLastBlockHash()`
 * @return {string}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.getLastBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getLastBlockHash()));
};


/**
 * optional bytes last_block_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getLastBlockHash()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.getLastBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getLastBlockHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.LastBlockChainState} returns this
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.setLastBlockHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * repeated LastBlockchainPendingEvent pending_block_events = 4;
 * @return {!Array<!proto.tolar.proto.storage.LastBlockchainPendingEvent>}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.getPendingBlockEventsList = function() {
  return /** @type{!Array<!proto.tolar.proto.storage.LastBlockchainPendingEvent>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.tolar.proto.storage.LastBlockchainPendingEvent, 4));
};


/**
 * @param {!Array<!proto.tolar.proto.storage.LastBlockchainPendingEvent>} value
 * @return {!proto.tolar.proto.storage.LastBlockChainState} returns this
*/
proto.tolar.proto.storage.LastBlockChainState.prototype.setPendingBlockEventsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.tolar.proto.storage.LastBlockchainPendingEvent=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tolar.proto.storage.LastBlockchainPendingEvent}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.addPendingBlockEvents = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.tolar.proto.storage.LastBlockchainPendingEvent, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.tolar.proto.storage.LastBlockChainState} returns this
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.clearPendingBlockEventsList = function() {
  return this.setPendingBlockEventsList([]);
};


/**
 * optional bytes last_events_proof_hash = 5;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.getLastEventsProofHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes last_events_proof_hash = 5;
 * This is a type-conversion wrapper around `getLastEventsProofHash()`
 * @return {string}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.getLastEventsProofHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getLastEventsProofHash()));
};


/**
 * optional bytes last_events_proof_hash = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getLastEventsProofHash()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.getLastEventsProofHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getLastEventsProofHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.LastBlockChainState} returns this
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.setLastEventsProofHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional uint64 next_pending_event_index = 6;
 * @return {number}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.getNextPendingEventIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.LastBlockChainState} returns this
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.setNextPendingEventIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * repeated LastBlockchainPendingEvent new_events = 7;
 * @return {!Array<!proto.tolar.proto.storage.LastBlockchainPendingEvent>}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.getNewEventsList = function() {
  return /** @type{!Array<!proto.tolar.proto.storage.LastBlockchainPendingEvent>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.tolar.proto.storage.LastBlockchainPendingEvent, 7));
};


/**
 * @param {!Array<!proto.tolar.proto.storage.LastBlockchainPendingEvent>} value
 * @return {!proto.tolar.proto.storage.LastBlockChainState} returns this
*/
proto.tolar.proto.storage.LastBlockChainState.prototype.setNewEventsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 7, value);
};


/**
 * @param {!proto.tolar.proto.storage.LastBlockchainPendingEvent=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tolar.proto.storage.LastBlockchainPendingEvent}
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.addNewEvents = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, proto.tolar.proto.storage.LastBlockchainPendingEvent, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.tolar.proto.storage.LastBlockChainState} returns this
 */
proto.tolar.proto.storage.LastBlockChainState.prototype.clearNewEventsList = function() {
  return this.setNewEventsList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.RecoverySnapshot.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.RecoverySnapshot} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.RecoverySnapshot.toObject = function(includeInstance, msg) {
  var f, obj = {
    bottomSnapshot: (f = msg.getBottomSnapshot()) && proto.tolar.proto.storage.Snapshot.toObject(includeInstance, f),
    consensusSnapshot: (f = msg.getConsensusSnapshot()) && proto.tolar.proto.storage.Snapshot.toObject(includeInstance, f),
    lowestSentinelRound: jspb.Message.getFieldWithDefault(msg, 3, 0),
    allWardenRound: jspb.Message.getFieldWithDefault(msg, 4, 0),
    lastBlockchainState: (f = msg.getLastBlockchainState()) && proto.tolar.proto.storage.LastBlockChainState.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.RecoverySnapshot}
 */
proto.tolar.proto.storage.RecoverySnapshot.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.RecoverySnapshot;
  return proto.tolar.proto.storage.RecoverySnapshot.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.RecoverySnapshot} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.RecoverySnapshot}
 */
proto.tolar.proto.storage.RecoverySnapshot.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.tolar.proto.storage.Snapshot;
      reader.readMessage(value,proto.tolar.proto.storage.Snapshot.deserializeBinaryFromReader);
      msg.setBottomSnapshot(value);
      break;
    case 2:
      var value = new proto.tolar.proto.storage.Snapshot;
      reader.readMessage(value,proto.tolar.proto.storage.Snapshot.deserializeBinaryFromReader);
      msg.setConsensusSnapshot(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setLowestSentinelRound(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAllWardenRound(value);
      break;
    case 5:
      var value = new proto.tolar.proto.storage.LastBlockChainState;
      reader.readMessage(value,proto.tolar.proto.storage.LastBlockChainState.deserializeBinaryFromReader);
      msg.setLastBlockchainState(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.RecoverySnapshot.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.RecoverySnapshot} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.RecoverySnapshot.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBottomSnapshot();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.tolar.proto.storage.Snapshot.serializeBinaryToWriter
    );
  }
  f = message.getConsensusSnapshot();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.tolar.proto.storage.Snapshot.serializeBinaryToWriter
    );
  }
  f = message.getLowestSentinelRound();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = message.getAllWardenRound();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = message.getLastBlockchainState();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.tolar.proto.storage.LastBlockChainState.serializeBinaryToWriter
    );
  }
};


/**
 * optional Snapshot bottom_snapshot = 1;
 * @return {?proto.tolar.proto.storage.Snapshot}
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.getBottomSnapshot = function() {
  return /** @type{?proto.tolar.proto.storage.Snapshot} */ (
    jspb.Message.getWrapperField(this, proto.tolar.proto.storage.Snapshot, 1));
};


/**
 * @param {?proto.tolar.proto.storage.Snapshot|undefined} value
 * @return {!proto.tolar.proto.storage.RecoverySnapshot} returns this
*/
proto.tolar.proto.storage.RecoverySnapshot.prototype.setBottomSnapshot = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.tolar.proto.storage.RecoverySnapshot} returns this
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.clearBottomSnapshot = function() {
  return this.setBottomSnapshot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.hasBottomSnapshot = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Snapshot consensus_snapshot = 2;
 * @return {?proto.tolar.proto.storage.Snapshot}
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.getConsensusSnapshot = function() {
  return /** @type{?proto.tolar.proto.storage.Snapshot} */ (
    jspb.Message.getWrapperField(this, proto.tolar.proto.storage.Snapshot, 2));
};


/**
 * @param {?proto.tolar.proto.storage.Snapshot|undefined} value
 * @return {!proto.tolar.proto.storage.RecoverySnapshot} returns this
*/
proto.tolar.proto.storage.RecoverySnapshot.prototype.setConsensusSnapshot = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.tolar.proto.storage.RecoverySnapshot} returns this
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.clearConsensusSnapshot = function() {
  return this.setConsensusSnapshot(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.hasConsensusSnapshot = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint64 lowest_sentinel_round = 3;
 * @return {number}
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.getLowestSentinelRound = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.RecoverySnapshot} returns this
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.setLowestSentinelRound = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional uint64 all_warden_round = 4;
 * @return {number}
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.getAllWardenRound = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.RecoverySnapshot} returns this
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.setAllWardenRound = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional LastBlockChainState last_blockchain_state = 5;
 * @return {?proto.tolar.proto.storage.LastBlockChainState}
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.getLastBlockchainState = function() {
  return /** @type{?proto.tolar.proto.storage.LastBlockChainState} */ (
    jspb.Message.getWrapperField(this, proto.tolar.proto.storage.LastBlockChainState, 5));
};


/**
 * @param {?proto.tolar.proto.storage.LastBlockChainState|undefined} value
 * @return {!proto.tolar.proto.storage.RecoverySnapshot} returns this
*/
proto.tolar.proto.storage.RecoverySnapshot.prototype.setLastBlockchainState = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.tolar.proto.storage.RecoverySnapshot} returns this
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.clearLastBlockchainState = function() {
  return this.setLastBlockchainState(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.tolar.proto.storage.RecoverySnapshot.prototype.hasLastBlockchainState = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.tolar.proto.storage.BlockBody.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.BlockBody.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.BlockBody.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.BlockBody} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.BlockBody.toObject = function(includeInstance, msg) {
  var f, obj = {
    index: jspb.Message.getFieldWithDefault(msg, 1, 0),
    roundReceived: jspb.Message.getFieldWithDefault(msg, 2, 0),
    previousBlockHash: msg.getPreviousBlockHash_asB64(),
    transactionsList: jspb.Message.toObjectList(msg.getTransactionsList(),
    tolar_proto_transaction_pb.ExecutedTransaction.toObject, includeInstance),
    eventsProofHash: msg.getEventsProofHash_asB64(),
    timestamp: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.BlockBody}
 */
proto.tolar.proto.storage.BlockBody.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.BlockBody;
  return proto.tolar.proto.storage.BlockBody.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.BlockBody} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.BlockBody}
 */
proto.tolar.proto.storage.BlockBody.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setRoundReceived(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPreviousBlockHash(value);
      break;
    case 4:
      var value = new tolar_proto_transaction_pb.ExecutedTransaction;
      reader.readMessage(value,tolar_proto_transaction_pb.ExecutedTransaction.deserializeBinaryFromReader);
      msg.addTransactions(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEventsProofHash(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTimestamp(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.BlockBody.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.BlockBody.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.BlockBody} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.BlockBody.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getRoundReceived();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getPreviousBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      tolar_proto_transaction_pb.ExecutedTransaction.serializeBinaryToWriter
    );
  }
  f = message.getEventsProofHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeUint64(
      6,
      f
    );
  }
};


/**
 * optional uint64 index = 1;
 * @return {number}
 */
proto.tolar.proto.storage.BlockBody.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.BlockBody} returns this
 */
proto.tolar.proto.storage.BlockBody.prototype.setIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 round_received = 2;
 * @return {number}
 */
proto.tolar.proto.storage.BlockBody.prototype.getRoundReceived = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.BlockBody} returns this
 */
proto.tolar.proto.storage.BlockBody.prototype.setRoundReceived = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes previous_block_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.BlockBody.prototype.getPreviousBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes previous_block_hash = 3;
 * This is a type-conversion wrapper around `getPreviousBlockHash()`
 * @return {string}
 */
proto.tolar.proto.storage.BlockBody.prototype.getPreviousBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPreviousBlockHash()));
};


/**
 * optional bytes previous_block_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPreviousBlockHash()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.BlockBody.prototype.getPreviousBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPreviousBlockHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.BlockBody} returns this
 */
proto.tolar.proto.storage.BlockBody.prototype.setPreviousBlockHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * repeated tolar.proto.tx.ExecutedTransaction transactions = 4;
 * @return {!Array<!proto.tolar.proto.tx.ExecutedTransaction>}
 */
proto.tolar.proto.storage.BlockBody.prototype.getTransactionsList = function() {
  return /** @type{!Array<!proto.tolar.proto.tx.ExecutedTransaction>} */ (
    jspb.Message.getRepeatedWrapperField(this, tolar_proto_transaction_pb.ExecutedTransaction, 4));
};


/**
 * @param {!Array<!proto.tolar.proto.tx.ExecutedTransaction>} value
 * @return {!proto.tolar.proto.storage.BlockBody} returns this
*/
proto.tolar.proto.storage.BlockBody.prototype.setTransactionsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.tolar.proto.tx.ExecutedTransaction=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tolar.proto.tx.ExecutedTransaction}
 */
proto.tolar.proto.storage.BlockBody.prototype.addTransactions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.tolar.proto.tx.ExecutedTransaction, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.tolar.proto.storage.BlockBody} returns this
 */
proto.tolar.proto.storage.BlockBody.prototype.clearTransactionsList = function() {
  return this.setTransactionsList([]);
};


/**
 * optional bytes events_proof_hash = 5;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.BlockBody.prototype.getEventsProofHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes events_proof_hash = 5;
 * This is a type-conversion wrapper around `getEventsProofHash()`
 * @return {string}
 */
proto.tolar.proto.storage.BlockBody.prototype.getEventsProofHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEventsProofHash()));
};


/**
 * optional bytes events_proof_hash = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEventsProofHash()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.BlockBody.prototype.getEventsProofHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEventsProofHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.BlockBody} returns this
 */
proto.tolar.proto.storage.BlockBody.prototype.setEventsProofHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional uint64 timestamp = 6;
 * @return {number}
 */
proto.tolar.proto.storage.BlockBody.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.BlockBody} returns this
 */
proto.tolar.proto.storage.BlockBody.prototype.setTimestamp = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.tolar.proto.storage.Block.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.Block.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.Block.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.Block} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.Block.toObject = function(includeInstance, msg) {
  var f, obj = {
    blockBody: (f = msg.getBlockBody()) && proto.tolar.proto.storage.BlockBody.toObject(includeInstance, f),
    blockValidatorsList: msg.getBlockValidatorsList_asB64(),
    stateRootHash: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.Block}
 */
proto.tolar.proto.storage.Block.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.Block;
  return proto.tolar.proto.storage.Block.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.Block} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.Block}
 */
proto.tolar.proto.storage.Block.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.tolar.proto.storage.BlockBody;
      reader.readMessage(value,proto.tolar.proto.storage.BlockBody.deserializeBinaryFromReader);
      msg.setBlockBody(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addBlockValidators(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setStateRootHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.Block.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.Block.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.Block} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.Block.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBlockBody();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.tolar.proto.storage.BlockBody.serializeBinaryToWriter
    );
  }
  f = message.getBlockValidatorsList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      2,
      f
    );
  }
  f = message.getStateRootHash();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional BlockBody block_body = 1;
 * @return {?proto.tolar.proto.storage.BlockBody}
 */
proto.tolar.proto.storage.Block.prototype.getBlockBody = function() {
  return /** @type{?proto.tolar.proto.storage.BlockBody} */ (
    jspb.Message.getWrapperField(this, proto.tolar.proto.storage.BlockBody, 1));
};


/**
 * @param {?proto.tolar.proto.storage.BlockBody|undefined} value
 * @return {!proto.tolar.proto.storage.Block} returns this
*/
proto.tolar.proto.storage.Block.prototype.setBlockBody = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.tolar.proto.storage.Block} returns this
 */
proto.tolar.proto.storage.Block.prototype.clearBlockBody = function() {
  return this.setBlockBody(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.tolar.proto.storage.Block.prototype.hasBlockBody = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated bytes block_validators = 2;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.tolar.proto.storage.Block.prototype.getBlockValidatorsList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * repeated bytes block_validators = 2;
 * This is a type-conversion wrapper around `getBlockValidatorsList()`
 * @return {!Array<string>}
 */
proto.tolar.proto.storage.Block.prototype.getBlockValidatorsList_asB64 = function() {
  return /** @type {!Array<string>} */ (jspb.Message.bytesListAsB64(
      this.getBlockValidatorsList()));
};


/**
 * repeated bytes block_validators = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockValidatorsList()`
 * @return {!Array<!Uint8Array>}
 */
proto.tolar.proto.storage.Block.prototype.getBlockValidatorsList_asU8 = function() {
  return /** @type {!Array<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getBlockValidatorsList()));
};


/**
 * @param {!(Array<!Uint8Array>|Array<string>)} value
 * @return {!proto.tolar.proto.storage.Block} returns this
 */
proto.tolar.proto.storage.Block.prototype.setBlockValidatorsList = function(value) {
  return jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 * @return {!proto.tolar.proto.storage.Block} returns this
 */
proto.tolar.proto.storage.Block.prototype.addBlockValidators = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.tolar.proto.storage.Block} returns this
 */
proto.tolar.proto.storage.Block.prototype.clearBlockValidatorsList = function() {
  return this.setBlockValidatorsList([]);
};


/**
 * optional string state_root_hash = 3;
 * @return {string}
 */
proto.tolar.proto.storage.Block.prototype.getStateRootHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.tolar.proto.storage.Block} returns this
 */
proto.tolar.proto.storage.Block.prototype.setStateRootHash = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.EventRelationsLookupElement.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.EventRelationsLookupElement.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.EventRelationsLookupElement} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.EventRelationsLookupElement.toObject = function(includeInstance, msg) {
  var f, obj = {
    chain: msg.getChain_asB64(),
    hash: msg.getHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.EventRelationsLookupElement}
 */
proto.tolar.proto.storage.EventRelationsLookupElement.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.EventRelationsLookupElement;
  return proto.tolar.proto.storage.EventRelationsLookupElement.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.EventRelationsLookupElement} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.EventRelationsLookupElement}
 */
proto.tolar.proto.storage.EventRelationsLookupElement.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChain(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.EventRelationsLookupElement.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.EventRelationsLookupElement.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.EventRelationsLookupElement} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.EventRelationsLookupElement.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChain_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes chain = 1;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.EventRelationsLookupElement.prototype.getChain = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes chain = 1;
 * This is a type-conversion wrapper around `getChain()`
 * @return {string}
 */
proto.tolar.proto.storage.EventRelationsLookupElement.prototype.getChain_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChain()));
};


/**
 * optional bytes chain = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChain()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.EventRelationsLookupElement.prototype.getChain_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChain()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.EventRelationsLookupElement} returns this
 */
proto.tolar.proto.storage.EventRelationsLookupElement.prototype.setChain = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.EventRelationsLookupElement.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes hash = 2;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.tolar.proto.storage.EventRelationsLookupElement.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.EventRelationsLookupElement.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.EventRelationsLookupElement} returns this
 */
proto.tolar.proto.storage.EventRelationsLookupElement.prototype.setHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.tolar.proto.storage.EventRelations.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.EventRelations.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.EventRelations.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.EventRelations} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.EventRelations.toObject = function(includeInstance, msg) {
  var f, obj = {
    eventHash: msg.getEventHash_asB64(),
    chainLookupList: jspb.Message.toObjectList(msg.getChainLookupList(),
    proto.tolar.proto.storage.EventRelationsLookupElement.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.EventRelations}
 */
proto.tolar.proto.storage.EventRelations.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.EventRelations;
  return proto.tolar.proto.storage.EventRelations.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.EventRelations} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.EventRelations}
 */
proto.tolar.proto.storage.EventRelations.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEventHash(value);
      break;
    case 2:
      var value = new proto.tolar.proto.storage.EventRelationsLookupElement;
      reader.readMessage(value,proto.tolar.proto.storage.EventRelationsLookupElement.deserializeBinaryFromReader);
      msg.addChainLookup(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.EventRelations.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.EventRelations.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.EventRelations} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.EventRelations.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEventHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getChainLookupList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.tolar.proto.storage.EventRelationsLookupElement.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes event_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.EventRelations.prototype.getEventHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes event_hash = 1;
 * This is a type-conversion wrapper around `getEventHash()`
 * @return {string}
 */
proto.tolar.proto.storage.EventRelations.prototype.getEventHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEventHash()));
};


/**
 * optional bytes event_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEventHash()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.EventRelations.prototype.getEventHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEventHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.EventRelations} returns this
 */
proto.tolar.proto.storage.EventRelations.prototype.setEventHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * repeated EventRelationsLookupElement chain_lookup = 2;
 * @return {!Array<!proto.tolar.proto.storage.EventRelationsLookupElement>}
 */
proto.tolar.proto.storage.EventRelations.prototype.getChainLookupList = function() {
  return /** @type{!Array<!proto.tolar.proto.storage.EventRelationsLookupElement>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.tolar.proto.storage.EventRelationsLookupElement, 2));
};


/**
 * @param {!Array<!proto.tolar.proto.storage.EventRelationsLookupElement>} value
 * @return {!proto.tolar.proto.storage.EventRelations} returns this
*/
proto.tolar.proto.storage.EventRelations.prototype.setChainLookupList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.tolar.proto.storage.EventRelationsLookupElement=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tolar.proto.storage.EventRelationsLookupElement}
 */
proto.tolar.proto.storage.EventRelations.prototype.addChainLookup = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tolar.proto.storage.EventRelationsLookupElement, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.tolar.proto.storage.EventRelations} returns this
 */
proto.tolar.proto.storage.EventRelations.prototype.clearChainLookupList = function() {
  return this.setChainLookupList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.EventLastAncestors.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.EventLastAncestors.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.EventLastAncestors} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.EventLastAncestors.toObject = function(includeInstance, msg) {
  var f, obj = {
    relations: (f = msg.getRelations()) && proto.tolar.proto.storage.EventRelations.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.EventLastAncestors}
 */
proto.tolar.proto.storage.EventLastAncestors.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.EventLastAncestors;
  return proto.tolar.proto.storage.EventLastAncestors.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.EventLastAncestors} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.EventLastAncestors}
 */
proto.tolar.proto.storage.EventLastAncestors.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.tolar.proto.storage.EventRelations;
      reader.readMessage(value,proto.tolar.proto.storage.EventRelations.deserializeBinaryFromReader);
      msg.setRelations(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.EventLastAncestors.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.EventLastAncestors.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.EventLastAncestors} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.EventLastAncestors.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRelations();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.tolar.proto.storage.EventRelations.serializeBinaryToWriter
    );
  }
};


/**
 * optional EventRelations relations = 1;
 * @return {?proto.tolar.proto.storage.EventRelations}
 */
proto.tolar.proto.storage.EventLastAncestors.prototype.getRelations = function() {
  return /** @type{?proto.tolar.proto.storage.EventRelations} */ (
    jspb.Message.getWrapperField(this, proto.tolar.proto.storage.EventRelations, 1));
};


/**
 * @param {?proto.tolar.proto.storage.EventRelations|undefined} value
 * @return {!proto.tolar.proto.storage.EventLastAncestors} returns this
*/
proto.tolar.proto.storage.EventLastAncestors.prototype.setRelations = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.tolar.proto.storage.EventLastAncestors} returns this
 */
proto.tolar.proto.storage.EventLastAncestors.prototype.clearRelations = function() {
  return this.setRelations(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.tolar.proto.storage.EventLastAncestors.prototype.hasRelations = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.EventFirstDescendants.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.EventFirstDescendants.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.EventFirstDescendants} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.EventFirstDescendants.toObject = function(includeInstance, msg) {
  var f, obj = {
    relations: (f = msg.getRelations()) && proto.tolar.proto.storage.EventRelations.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.EventFirstDescendants}
 */
proto.tolar.proto.storage.EventFirstDescendants.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.EventFirstDescendants;
  return proto.tolar.proto.storage.EventFirstDescendants.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.EventFirstDescendants} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.EventFirstDescendants}
 */
proto.tolar.proto.storage.EventFirstDescendants.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.tolar.proto.storage.EventRelations;
      reader.readMessage(value,proto.tolar.proto.storage.EventRelations.deserializeBinaryFromReader);
      msg.setRelations(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.EventFirstDescendants.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.EventFirstDescendants.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.EventFirstDescendants} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.EventFirstDescendants.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRelations();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.tolar.proto.storage.EventRelations.serializeBinaryToWriter
    );
  }
};


/**
 * optional EventRelations relations = 1;
 * @return {?proto.tolar.proto.storage.EventRelations}
 */
proto.tolar.proto.storage.EventFirstDescendants.prototype.getRelations = function() {
  return /** @type{?proto.tolar.proto.storage.EventRelations} */ (
    jspb.Message.getWrapperField(this, proto.tolar.proto.storage.EventRelations, 1));
};


/**
 * @param {?proto.tolar.proto.storage.EventRelations|undefined} value
 * @return {!proto.tolar.proto.storage.EventFirstDescendants} returns this
*/
proto.tolar.proto.storage.EventFirstDescendants.prototype.setRelations = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.tolar.proto.storage.EventFirstDescendants} returns this
 */
proto.tolar.proto.storage.EventFirstDescendants.prototype.clearRelations = function() {
  return this.setRelations(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.tolar.proto.storage.EventFirstDescendants.prototype.hasRelations = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.LatestValidBlock.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.LatestValidBlock.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.LatestValidBlock} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.LatestValidBlock.toObject = function(includeInstance, msg) {
  var f, obj = {
    index: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.LatestValidBlock}
 */
proto.tolar.proto.storage.LatestValidBlock.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.LatestValidBlock;
  return proto.tolar.proto.storage.LatestValidBlock.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.LatestValidBlock} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.LatestValidBlock}
 */
proto.tolar.proto.storage.LatestValidBlock.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.LatestValidBlock.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.LatestValidBlock.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.LatestValidBlock} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.LatestValidBlock.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
};


/**
 * optional uint64 index = 1;
 * @return {number}
 */
proto.tolar.proto.storage.LatestValidBlock.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.tolar.proto.storage.LatestValidBlock} returns this
 */
proto.tolar.proto.storage.LatestValidBlock.prototype.setIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.InitialEventsElement.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.InitialEventsElement.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.InitialEventsElement} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.InitialEventsElement.toObject = function(includeInstance, msg) {
  var f, obj = {
    chain: msg.getChain_asB64(),
    hash: msg.getHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.InitialEventsElement}
 */
proto.tolar.proto.storage.InitialEventsElement.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.InitialEventsElement;
  return proto.tolar.proto.storage.InitialEventsElement.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.InitialEventsElement} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.InitialEventsElement}
 */
proto.tolar.proto.storage.InitialEventsElement.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChain(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.InitialEventsElement.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.InitialEventsElement.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.InitialEventsElement} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.InitialEventsElement.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChain_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes chain = 1;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.InitialEventsElement.prototype.getChain = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes chain = 1;
 * This is a type-conversion wrapper around `getChain()`
 * @return {string}
 */
proto.tolar.proto.storage.InitialEventsElement.prototype.getChain_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChain()));
};


/**
 * optional bytes chain = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChain()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.InitialEventsElement.prototype.getChain_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChain()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.InitialEventsElement} returns this
 */
proto.tolar.proto.storage.InitialEventsElement.prototype.setChain = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.tolar.proto.storage.InitialEventsElement.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes hash = 2;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.tolar.proto.storage.InitialEventsElement.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.InitialEventsElement.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.tolar.proto.storage.InitialEventsElement} returns this
 */
proto.tolar.proto.storage.InitialEventsElement.prototype.setHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.tolar.proto.storage.InitialEvents.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.tolar.proto.storage.InitialEvents.prototype.toObject = function(opt_includeInstance) {
  return proto.tolar.proto.storage.InitialEvents.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.tolar.proto.storage.InitialEvents} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.InitialEvents.toObject = function(includeInstance, msg) {
  var f, obj = {
    elementsList: jspb.Message.toObjectList(msg.getElementsList(),
    proto.tolar.proto.storage.InitialEventsElement.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tolar.proto.storage.InitialEvents}
 */
proto.tolar.proto.storage.InitialEvents.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tolar.proto.storage.InitialEvents;
  return proto.tolar.proto.storage.InitialEvents.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tolar.proto.storage.InitialEvents} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tolar.proto.storage.InitialEvents}
 */
proto.tolar.proto.storage.InitialEvents.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.tolar.proto.storage.InitialEventsElement;
      reader.readMessage(value,proto.tolar.proto.storage.InitialEventsElement.deserializeBinaryFromReader);
      msg.addElements(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.tolar.proto.storage.InitialEvents.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.tolar.proto.storage.InitialEvents.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tolar.proto.storage.InitialEvents} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.tolar.proto.storage.InitialEvents.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getElementsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.tolar.proto.storage.InitialEventsElement.serializeBinaryToWriter
    );
  }
};


/**
 * repeated InitialEventsElement elements = 1;
 * @return {!Array<!proto.tolar.proto.storage.InitialEventsElement>}
 */
proto.tolar.proto.storage.InitialEvents.prototype.getElementsList = function() {
  return /** @type{!Array<!proto.tolar.proto.storage.InitialEventsElement>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.tolar.proto.storage.InitialEventsElement, 1));
};


/**
 * @param {!Array<!proto.tolar.proto.storage.InitialEventsElement>} value
 * @return {!proto.tolar.proto.storage.InitialEvents} returns this
*/
proto.tolar.proto.storage.InitialEvents.prototype.setElementsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.tolar.proto.storage.InitialEventsElement=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tolar.proto.storage.InitialEventsElement}
 */
proto.tolar.proto.storage.InitialEvents.prototype.addElements = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tolar.proto.storage.InitialEventsElement, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.tolar.proto.storage.InitialEvents} returns this
 */
proto.tolar.proto.storage.InitialEvents.prototype.clearElementsList = function() {
  return this.setElementsList([]);
};


/**
 * @enum {number}
 */
proto.tolar.proto.storage.SentinelRank = {
  UNDECIDED: 0,
  SENTINEL: 1,
  WARDEN: 2
};

goog.object.extend(exports, proto.tolar.proto.storage);
